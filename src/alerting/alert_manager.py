"""Leak Detection & Alerting System â€” real-time alerts via Slack, Email, Webhook."""

from __future__ import annotations

import json
import logging
from abc import ABC, abstractmethod
from datetime import datetime, timezone
from typing import Any

import httpx

from ..core import get_settings

logger = logging.getLogger(__name__)


class AlertChannel(ABC):
    """Abstract alert channel."""

    @abstractmethod
    async def send(self, alert: dict[str, Any]) -> bool:
        ...


class SlackAlertChannel(AlertChannel):
    """Send alerts to Slack via webhook."""

    def __init__(self, webhook_url: str) -> None:
        self.webhook_url = webhook_url

    async def send(self, alert: dict[str, Any]) -> bool:
        severity = alert.get("severity", "medium")
        color_map = {"critical": "#dc3545", "high": "#fd7e14", "medium": "#ffc107", "low": "#28a745"}
        color = color_map.get(severity, "#6c757d")

        payload = {
            "attachments": [{
                "color": color,
                "title": f"ðŸ›¡ï¸ PII Shield Alert â€” {severity.upper()}",
                "text": alert.get("title", "PII Detection Alert"),
                "fields": [
                    {"title": "Severity", "value": severity.upper(), "short": True},
                    {"title": "Entity Type", "value": alert.get("entity_type", "N/A"), "short": True},
                    {"title": "Source", "value": alert.get("source", "N/A"), "short": True},
                    {"title": "Risk Score", "value": str(alert.get("risk_score", "N/A")), "short": True},
                    {"title": "Details", "value": alert.get("message", ""), "short": False},
                ],
                "footer": "PII Shield Compliance Engine",
                "ts": int(datetime.now(timezone.utc).timestamp()),
            }]
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(self.webhook_url, json=payload, timeout=10)
                return response.status_code == 200
        except Exception as e:
            logger.error(f"Slack alert failed: {e}")
            return False


class EmailAlertChannel(AlertChannel):
    """Send alerts via email (SMTP)."""

    def __init__(self, smtp_host: str, smtp_port: int, username: str, password: str, from_addr: str, to_addr: str) -> None:
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.from_addr = from_addr
        self.to_addr = to_addr

    async def send(self, alert: dict[str, Any]) -> bool:
        try:
            import aiosmtplib  # type: ignore[import-not-found]
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart

            severity = alert.get("severity", "medium").upper()
            msg = MIMEMultipart("alternative")
            msg["Subject"] = f"[PII Shield] {severity} Alert: {alert.get('title', 'PII Detection')}"
            msg["From"] = self.from_addr
            msg["To"] = self.to_addr

            body = f"""
PII Shield Security Alert
{'='*50}

Severity: {severity}
Entity Type: {alert.get('entity_type', 'N/A')}
Source: {alert.get('source', 'N/A')}
Risk Score: {alert.get('risk_score', 'N/A')}

Details:
{alert.get('message', 'No details available.')}

Remediation:
{alert.get('remediation', 'Review and address the finding.')}

Compliance Impact:
{', '.join(alert.get('regulations_impacted', ['N/A']))}

---
Generated by PII Shield at {datetime.now(timezone.utc).isoformat()}
"""
            msg.attach(MIMEText(body, "plain"))

            await aiosmtplib.send(
                msg,
                hostname=self.smtp_host,
                port=self.smtp_port,
                username=self.username,
                password=self.password,
                use_tls=True,
            )
            return True
        except Exception as e:
            logger.error(f"Email alert failed: {e}")
            return False


class WebhookAlertChannel(AlertChannel):
    """Send alerts to a generic webhook endpoint."""

    def __init__(self, url: str) -> None:
        self.url = url

    async def send(self, alert: dict[str, Any]) -> bool:
        payload = {
            "event": "pii_detection",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "severity": alert.get("severity"),
            "title": alert.get("title"),
            "entity_type": alert.get("entity_type"),
            "risk_score": alert.get("risk_score"),
            "source": alert.get("source"),
            "message": alert.get("message"),
            "regulations_impacted": alert.get("regulations_impacted", []),
            "remediation": alert.get("remediation"),
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(self.url, json=payload, timeout=10)
                return 200 <= response.status_code < 300
        except Exception as e:
            logger.error(f"Webhook alert failed: {e}")
            return False


class AlertManager:
    """
    Manages alert generation, deduplication, and dispatch.
    
    Features:
    - Severity-based filtering and escalation
    - Cooldown to prevent alert fatigue
    - Multi-channel dispatch (Slack, Email, Webhook)
    - Auto-generated remediation suggestions
    """

    def __init__(self) -> None:
        self.channels: list[AlertChannel] = []
        self.min_severity = "high"
        self._cooldown_cache: dict[str, datetime] = {}
        self._cooldown_seconds = 300
        self._initialize_channels()

    def _initialize_channels(self) -> None:
        settings = get_settings()

        if settings.slack_webhook_url:
            self.channels.append(SlackAlertChannel(settings.slack_webhook_url))
            logger.info("Slack alert channel configured")

        if settings.smtp_user and settings.smtp_password:
            self.channels.append(EmailAlertChannel(
                smtp_host=settings.smtp_host,
                smtp_port=settings.smtp_port,
                username=settings.smtp_user,
                password=settings.smtp_password,
                from_addr=settings.alert_email_from,
                to_addr=settings.alert_email_to,
            ))
            logger.info("Email alert channel configured")

        if settings.webhook_alert_url:
            self.channels.append(WebhookAlertChannel(settings.webhook_alert_url))
            logger.info("Webhook alert channel configured")

    def _severity_rank(self, severity: str) -> int:
        return {"low": 0, "medium": 1, "high": 2, "critical": 3}.get(severity, 0)

    def _should_alert(self, alert_key: str, severity: str) -> bool:
        # Check minimum severity
        if self._severity_rank(severity) < self._severity_rank(self.min_severity):
            return False

        # Check cooldown
        now = datetime.now(timezone.utc)
        last_sent = self._cooldown_cache.get(alert_key)
        if last_sent and (now - last_sent).total_seconds() < self._cooldown_seconds:
            return False

        return True

    async def process_findings(self, scan_result: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate and send alerts for scan findings."""
        findings = scan_result.get("findings", [])
        source_name = scan_result.get("source", {}).get("name", "unknown")
        alerts_sent: list[dict[str, Any]] = []

        for finding in findings:
            severity = finding.get("sensitivity", finding.get("risk_tier", "medium"))
            entity_type = finding.get("entity_type", "unknown")
            alert_key = f"{entity_type}:{source_name}:{severity}"

            if not self._should_alert(alert_key, severity):
                continue

            alert = {
                "severity": severity,
                "title": f"PII Leak Detected: {entity_type}",
                "entity_type": entity_type,
                "source": source_name,
                "risk_score": finding.get("risk_score", 0.0),
                "message": self._build_alert_message(finding),
                "regulations_impacted": finding.get("regulations_impacted", []),
                "remediation": self._extract_remediation(finding),
            }

            success = await self._dispatch(alert)
            if success:
                self._cooldown_cache[alert_key] = datetime.now(timezone.utc)
                alerts_sent.append(alert)

        return alerts_sent

    async def _dispatch(self, alert: dict[str, Any]) -> bool:
        """Send alert to all configured channels."""
        if not self.channels:
            logger.debug("No alert channels configured")
            return False

        results = []
        for channel in self.channels:
            try:
                ok = await channel.send(alert)
                results.append(ok)
            except Exception as e:
                logger.error(f"Alert dispatch error: {e}")
                results.append(False)

        return any(results)

    def _build_alert_message(self, finding: dict[str, Any]) -> str:
        parts = [
            f"Entity: {finding.get('entity_type', 'unknown')}",
            f"Confidence: {finding.get('confidence', 0):.1%}",
            f"Risk: {finding.get('risk_tier', 'unknown')}",
        ]
        violations = finding.get("compliance_violations", [])
        if violations:
            fw = sorted(set(v["framework"] for v in violations))
            parts.append(f"Frameworks: {', '.join(fw)}")

        explanation = finding.get("explanation", {})
        if isinstance(explanation, dict) and "summary" in explanation:
            parts.append(f"Summary: {explanation['summary']}")

        return " | ".join(parts)

    def _extract_remediation(self, finding: dict[str, Any]) -> str:
        explanation = finding.get("explanation", {})
        if isinstance(explanation, dict) and "remediation" in explanation:
            return explanation["remediation"]
        violations = finding.get("compliance_violations", [])
        if violations:
            return violations[0].get("remediation", "Review and remediate finding.")
        return "Review and remediate this PII exposure."
